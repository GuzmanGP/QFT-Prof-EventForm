El problema de que se añadan o eliminen más filas de las esperadas parece estar relacionado con el manejo de los botones en la sección de metadatos. El comportamiento de los botones está definido en las funciones que controlan el contador y la manipulación de los campos de metadatos.

En particular:

Función setupCounterButtons (en metadataFields.js):

Este código asegura que al pulsar los botones, se añadan o eliminen campos en el contenedor correspondiente:
javascript
Copiar código
button.addEventListener('click', () => {
    const currentCount = parseInt(display.textContent);
    const isIncrease = button.classList.contains('increase-count');
    const newCount = isIncrease ? currentCount + 1 : Math.max(0, currentCount - 1);
    
    if (newCount <= 20) {
        display.textContent = newCount;
        if (isIncrease) {
            addMetadataField(container);
        } else if (container.children.length > 0) {
            const lastField = container.lastChild;
            lastField.classList.add('animate__fadeOutRight');
            setTimeout(() => container.removeChild(lastField), 500);
        }
    }
});
Función addMetadataField:

Cada vez que se añade un campo, se genera un evento de eliminación que podría no estar controlado adecuadamente, haciendo que más elementos sean afectados:
javascript
Copiar código
removeButton.addEventListener('click', () => {
    const display = container.closest('.metadata-section').querySelector('.counter-display');
    const currentCount = parseInt(display.textContent);

    field.classList.add('animate__fadeOutRight');
    setTimeout(() => {
        field.remove();
        display.textContent = (currentCount - 1).toString();
    }, 500);
});
Posible causa del problema:

Eventos duplicados: Si los eventos se asignan incorrectamente o varias veces (por ejemplo, al inicializar varias veces el formulario o el componente), los clics podrían estar activando más de una acción.
Selección del contenedor errónea: Si el selector del contenedor está apuntando a múltiples elementos, la manipulación puede afectar a más campos de los esperados.
Revisión rápida:

Asegúrate de que la función setupCounterButtons se llama una sola vez por contenedor.
Verifica que los eventos no estén siendo asignados varias veces al mismo botón.
Comprueba que container está apuntando al elemento correcto y único.
Solución sugerida:
Agrega una verificación en setupCounterButtons para evitar inicializaciones repetidas:

javascript
Copiar código
function setupCounterButtons(buttons, container, display) {
    if (container.dataset.initialized) return; // Evita reinicializaciones
    container.dataset.initialized = true;

    buttons.forEach(button => {
        button.addEventListener('click', () => {
            const currentCount = parseInt(display.textContent);
            const isIncrease = button.classList.contains('increase-count');
            const newCount = isIncrease ? currentCount + 1 : Math.max(0, currentCount - 1);

            if (newCount <= 20) {
                display.textContent = newCount;
                if (isIncrease) {
                    addMetadataField(container);
                } else if (container.children.length > 0) {
                    const lastField = container.lastChild;
                    lastField.classList.add('animate__fadeOutRight');
                    setTimeout(() => container.removeChild(lastField), 500);
                }
            }
        });
    });
}
Si el problema persiste tras implementar esta revisión, es necesario rastrear dónde se inicializan los contenedores y los botones para evitar múltiples asignaciones.