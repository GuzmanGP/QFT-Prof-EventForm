# Form Configuration System Implementation Guide

## 1. Database Structure

### FormConfiguration Model
```python
class FormConfiguration(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    category = db.Column(db.String(100), nullable=False)
    subcategory = db.Column(db.String(100))
    category_metadata = db.Column(JSONB, default={})
    subcategory_metadata = db.Column(JSONB, default={})
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    questions = db.relationship('Question', backref='form', cascade='all, delete-orphan')
```

### Question Model
```python
class Question(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    form_id = db.Column(db.Integer, db.ForeignKey('form_configuration.id'), nullable=False)
    reference = db.Column(db.String(50), nullable=False)
    content = db.Column(db.Text, nullable=False)
    answer_type = db.Column(db.String(20), nullable=False)
    options = db.Column(JSONB, default=[])
    question_metadata = db.Column(JSONB, default={})
    required = db.Column(db.Boolean, default=False)
    order = db.Column(db.Integer)
    ai_instructions = db.Column(db.Text)
```

### Key Features:
- JSONB columns for flexible metadata storage
- Cascading deletes for questions when form is deleted
- Automatic timestamps for creation and updates
- Proper foreign key constraints
- Indexed fields for performance

## 2. Backend Setup

### Flask Application Structure
```
project/
├── app.py              # Application initialization
├── models.py           # Database models
├── routes.py           # Route handlers
├── static/            
│   ├── css/           # Stylesheets
│   └── js/            # JavaScript files
└── templates/          # Jinja2 templates
```

### Database Configuration
```python
# app.py
app.config["SQLALCHEMY_DATABASE_URI"] = DATABASE_URL
app.config["SQLALCHEMY_ENGINE_OPTIONS"] = {
    "pool_recycle": 300,
    "pool_pre_ping": True,
    "pool_size": 20,
    "max_overflow": 40,
    "pool_timeout": 30
}
```

### Error Handling
```python
# routes.py
@app.errorhandler(404)
def not_found_error(error):
    return render_template('error.html', error="Página no encontrada"), 404

@app.errorhandler(500)
def internal_error(error):
    db.session.rollback()
    return render_template('error.html', error="Error interno del servidor"), 500
```

### Retry Mechanism
```python
def retry_database_operation(operation, max_retries=3, delay=1):
    for attempt in range(max_retries):
        try:
            return operation()
        except Exception as e:
            if attempt == max_retries - 1:
                raise
            time.sleep(delay * (2 ** attempt))
```

## 3. Frontend Components

### Base Template Structure
```html
<!-- base.html -->
<!DOCTYPE html>
<html lang="es" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestor de preguntas de usuarios</title>
    <link rel="stylesheet" href="https://cdn.replit.com/agent/bootstrap-agent-dark-theme.min.css">
</head>
<body>
    <!-- Sidebar navigation -->
    <div class="sidebar">
        <nav class="nav flex-column">
            <!-- Navigation items -->
        </nav>
    </div>
    
    <!-- Main content -->
    <div class="main-content">
        {% block content %}{% endblock %}
    </div>
</body>
</html>
```

### Metadata Management Component
```javascript
function updateMetadataFields(containerId, count) {
    if (count > 20) {
        showAlert('warning', 'No se pueden agregar más de 20 metadatos');
        return;
    }
    
    const container = document.getElementById(containerId);
    const currentFields = container.querySelectorAll('.input-group');
    
    // Add or remove fields as needed
    if (count > currentFields.length) {
        for (let i = currentFields.length; i < count; i++) {
            addMetadataField(containerId);
        }
    } else {
        while (container.children.length > count) {
            container.removeChild(container.lastChild);
        }
    }
}
```

### Question Management Component
```javascript
function addQuestion(existingQuestion = null) {
    const questionCard = document.createElement('div');
    questionCard.className = 'card mb-3 question-card';
    
    // Question fields (reference, content, type, etc.)
    questionCard.innerHTML = `
        <div class="card-body">
            <!-- Question fields -->
            <div class="metadata-section">
                <!-- Metadata counter -->
                <div class="metadata-container">
                    <!-- Metadata fields -->
                </div>
            </div>
        </div>
    `;
    
    document.getElementById('questions').appendChild(questionCard);
}
```

## 4. Form Configuration

### Category/Subcategory Implementation
```html
<div class="mb-3">
    <label class="form-label">Categoría<span class="text-danger">*</span></label>
    <input type="text" class="form-control" name="category" required>
    
    <!-- Category Metadata -->
    <div class="metadata-section">
        <div class="d-flex justify-content-between align-items-center">
            <h6>Metadatos</h6>
            <input type="number" class="form-control" id="categoryMetaCount" value="0" min="0" max="20">
        </div>
        <div id="categoryMetadata"></div>
    </div>
</div>
```

### AI Processing Integration
```javascript
function toggleAIInstructions() {
    const aiEnabled = document.getElementById('aiProcessing').checked;
    document.querySelectorAll('.ai-instructions').forEach(div => {
        div.style.display = aiEnabled ? 'block' : 'none';
    });
}
```

### Field Validation
```javascript
// Frontend validation
form.addEventListener('submit', async function(e) {
    e.preventDefault();
    if (!form.checkValidity()) {
        e.stopPropagation();
        form.classList.add('was-validated');
        return;
    }
    // Proceed with submission
});

// Backend validation
def validate_form_data(data):
    if not data.get('category'):
        raise ValueError("Category is required")
    if not data.get('questions'):
        raise ValueError("At least one question is required")
```

## 5. Form Submission Flow

### Data Collection
```javascript
function getFormData() {
    return {
        category: document.querySelector('[name="category"]').value,
        subcategory: document.querySelector('[name="subcategory"]').value,
        category_metadata: getMetadataValues('categoryMetadata'),
        subcategory_metadata: getMetadataValues('subcategoryMetadata'),
        questions: getQuestionsData(),
        ai_processing: document.getElementById('aiProcessing').checked
    };
}
```

### AJAX Submission
```javascript
async function submitForm(formData) {
    try {
        const response = await fetch('/api/forms', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(formData)
        });
        
        const data = await response.json();
        if (data.success) {
            showAlert('success', 'Formulario guardado exitosamente');
            resetForm();
        } else {
            throw new Error(data.error);
        }
    } catch (error) {
        showAlert('danger', error.message);
    }
}
```

### Error Handling
```javascript
function showAlert(type, message) {
    const alert = document.createElement('div');
    alert.className = `alert alert-${type} alert-dismissible fade show`;
    alert.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    document.querySelector('.alert-container').appendChild(alert);
    
    setTimeout(() => alert.remove(), 5000);
}
```

## 6. Testing Infrastructure

### Unit Tests Setup (pytest)
```python
# test_models.py
def test_form_configuration_model(app):
    with app.app_context():
        form = FormConfiguration(
            title="Test Form",
            category="Test Category",
            subcategory="Test Subcategory"
        )
        db.session.add(form)
        db.session.commit()
        
        assert form.id is not None
        assert form.category == "Test Category"
```

### Frontend Tests (Jest)
```javascript
// form_config.test.js
describe('Form Configuration', () => {
    test('updateMetadataFields creates correct number of input groups', () => {
        updateMetadataFields('categoryMetadata', 2);
        const inputGroups = document.querySelectorAll('#categoryMetadata .input-group');
        expect(inputGroups.length).toBe(2);
    });
});
```

### End-to-End Tests (Cypress)
```javascript
// form.cy.js
describe('Form Configuration', () => {
    beforeEach(() => {
        cy.visit('/form/new');
    });
    
    it('should submit form successfully', () => {
        cy.get('[name="category"]').type('Test Category');
        cy.get('[name="reference"]').type('Q1');
        cy.get('[name="content"]').type('Test Question');
        cy.get('button[type="submit"]').click();
        cy.get('.alert-success').should('be.visible');
    });
});
```

### Test Data Preparation
```python
@pytest.fixture
def sample_form():
    form = FormConfiguration(
        title="Test Form",
        category="Test Category",
        subcategory="Test Subcategory",
        category_metadata={"key": "value"},
        subcategory_metadata={"key": "value"}
    )
    
    question = Question(
        reference="Q1",
        content="Test Question",
        answer_type="text",
        required=True,
        order=1
    )
    
    form.questions.append(question)
    return form
```

## Performance Optimizations

1. Database Optimization:
- Proper indexing on frequently queried fields
- Connection pooling configuration
- Query optimization using eager loading

2. Frontend Performance:
- Lazy loading of components
- Caching of static assets
- Debounced event handlers
- Efficient DOM manipulation

3. Caching Strategy:
- Response caching for static content
- Form data caching during editing
- Session storage for temporary data

4. Error Recovery:
- Automatic retry mechanism for failed operations
- Graceful degradation
- Proper error feedback to users

## Maintenance and Monitoring

1. Logging:
- Structured logging for all operations
- Error tracking and reporting
- Performance monitoring

2. Database Maintenance:
- Regular cleanup of old sessions
- Index maintenance
- Backup strategy

3. Security:
- Input validation and sanitization
- CSRF protection
- Rate limiting

## Deployment Considerations

1. Environment Setup:
- Proper environment variables
- Database connection configuration
- Static file serving

2. Performance Monitoring:
- Application metrics
- Error tracking
- User analytics

3. Backup Strategy:
- Database backups
- Configuration backups
- Recovery procedures
